set default_table_access_method=ao_column;
set optimizer=off;
create table subquery_tbl(cnt int, v int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'cnt' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into subquery_tbl values(121, 1);
insert into subquery_tbl values(2, 1);
insert into subquery_tbl values(-2, 2);
insert into subquery_tbl values(-2, 1);
insert into subquery_tbl values(3, 1);
insert into subquery_tbl values(4, 2);
explain select cnt + 1 from (select count(*) as cnt from subquery_tbl group by v) v where cnt > 0;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Vec Gather Motion 3:1  (slice1; segments: 3)  (cost=499.50..509.50 rows=333 width=8)
   ->  Vec Subquery Scan on v  (cost=499.50..505.06 rows=111 width=8)
         ->  Vec Finalize Vec HashAggregate  (cost=499.50..503.67 rows=111 width=12)
               Group Key: subquery_tbl.v
               Filter: (count(*) > 0)
               ->  Vec Redistribute Motion 3:3  (slice2; segments: 3)  (cost=464.50..494.50 rows=1000 width=12)
                     Hash Key: subquery_tbl.v
                     ->  Vec Partial Vec HashAggregate  (cost=464.50..474.50 rows=1000 width=12)
                           Group Key: subquery_tbl.v
                           ->  Vec Seq Scan on subquery_tbl  (cost=0.00..321.00 rows=28700 width=4)
 Optimizer: Postgres query optimizer
(11 rows)

select cnt + 1 from (select count(*) as cnt from subquery_tbl group by v) v where cnt > 0;
 ?column? 
----------
        3
        5
(2 rows)

drop table subquery_tbl;
