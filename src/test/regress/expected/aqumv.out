--
-- Tests of Answer Query Using Materialized Views.
--
set optimizer = off;
create table aqumv_t1(c1 int, c2 int, c3 int) distributed by (c1);
insert into aqumv_t1 select i, i+1, i+2 from generate_series(1, 1000) i;
insert into aqumv_t1 select * from aqumv_t1;
analyze aqumv_t1;
set enable_answer_query_using_materialized_views = on;
-- drop views if there is no data populated
begin;
create incremental materialized view aqumv_mvt1_need_refresh as select * from aqumv_t1 where c1 = 2 with no data;
set local enable_answer_query_using_materialized_views = on;
explain(verbose, costs off) select * from aqumv_t1 where c1 = 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   Output: c1, c2, c3
   ->  Seq Scan on public.aqumv_t1
         Output: c1, c2, c3
         Filter: (aqumv_t1.c1 = 2)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

refresh materialized view aqumv_mvt1_need_refresh;
analyze aqumv_mvt1_need_refresh;
explain(verbose, costs off) select * from aqumv_t1 where c1 = 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c1, c2, c3
   ->  Seq Scan on public.aqumv_mvt1_need_refresh
         Output: c1, c2, c3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

abort;
begin;
create incremental materialized view aqumv_mvt1_0 as select * from aqumv_t1 where c1 = 2;
analyze aqumv_mvt1_0;
set local enable_answer_query_using_materialized_views = off;
select * from aqumv_t1 where c1 = 2;
 c1 | c2 | c3 
----+----+----
  2 |  3 |  4
  2 |  3 |  4
(2 rows)

select c1, c2, c3 from aqumv_t1 where c1 = 2;
 c1 | c2 | c3 
----+----+----
  2 |  3 |  4
  2 |  3 |  4
(2 rows)

select c2 from aqumv_t1 where c1 = 2;
 c2 
----
  3
  3
(2 rows)

select c3, c2 from aqumv_t1 where c1 = 2;
 c3 | c2 
----+----
  4 |  3
  4 |  3
(2 rows)

set local enable_answer_query_using_materialized_views = on;
select * from aqumv_t1 where c1 = 2;
 c1 | c2 | c3 
----+----+----
  2 |  3 |  4
  2 |  3 |  4
(2 rows)

select c1, c2, c3 from aqumv_t1 where c1 = 2;
 c1 | c2 | c3 
----+----+----
  2 |  3 |  4
  2 |  3 |  4
(2 rows)

select c2 from aqumv_t1 where c1 = 2;
 c2 
----
  3
  3
(2 rows)

select c3, c2 from aqumv_t1 where c1 = 2;
 c3 | c2 
----+----
  4 |  3
  4 |  3
(2 rows)

-- tlist matched.
explain(verbose, costs off) select * from aqumv_t1 where c1 = 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c1, c2, c3
   ->  Seq Scan on public.aqumv_mvt1_0
         Output: c1, c2, c3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

explain(verbose, costs off) select c1, c2, c3 from aqumv_t1 where c1 = 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c1, c2, c3
   ->  Seq Scan on public.aqumv_mvt1_0
         Output: c1, c2, c3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

-- tlist partially matched.
explain(verbose, costs off) select c2 from aqumv_t1 where c1 = 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c2
   ->  Seq Scan on public.aqumv_mvt1_0
         Output: c2
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

-- tlist disorder.
explain(verbose, costs off) select c3, c2 from aqumv_t1 where c1 = 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c3, c2
   ->  Seq Scan on public.aqumv_mvt1_0
         Output: c3, c2
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

abort;
begin;
create incremental materialized view aqumv_mvt1_1 as select c2 as mc2, c3 as mc3, c1 as mc1, c2 as mc2_1 from aqumv_t1 where c1 = 3;
analyze aqumv_mvt1_1;
set local enable_answer_query_using_materialized_views = off;
select c1 as col1, c2 as col2 from aqumv_t1 where c1 = 3;
 col1 | col2 
------+------
    3 |    4
    3 |    4
(2 rows)

select c1, c1 from aqumv_t1 where c1 = 3;
 c1 | c1 
----+----
  3 |  3
  3 |  3
(2 rows)

set local enable_answer_query_using_materialized_views = on;
select c1 as col1, c2 as col2 from aqumv_t1 where c1 = 3;
 col1 | col2 
------+------
    3 |    4
    3 |    4
(2 rows)

select c1, c1 from aqumv_t1 where c1 = 3;
 c1 | c1 
----+----
  3 |  3
  3 |  3
(2 rows)

-- tlist alias.
explain(verbose, costs off) select c1 as col1, c2 as col2 from aqumv_t1 where c1 = 3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, mc2
   ->  Seq Scan on public.aqumv_mvt1_1
         Output: mc1, mc2
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

-- duplicated projection.
explain(verbose, costs off) select c1, c1 from aqumv_t1 where c1 = 3;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, mc1
   ->  Seq Scan on public.aqumv_mvt1_1
         Output: mc1, mc1
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

abort;
begin;
create incremental materialized view aqumv_mvt1_nonvar_expr as
  select c2, 1 as mc_const_1, sqrt(100) as mc_sqrt_100
  from aqumv_t1 where c1 = 4;
analyze aqumv_mvt1_nonvar_expr;
set local enable_answer_query_using_materialized_views = off;
select c2, 200 from aqumv_t1 where c1 = 4;
 c2 | ?column? 
----+----------
  5 |      200
  5 |      200
(2 rows)

select c2, 1, sqrt(100) from aqumv_t1 where c1 = 4;
 c2 | ?column? | sqrt 
----+----------+------
  5 |        1 |   10
  5 |        1 |   10
(2 rows)

set local enable_answer_query_using_materialized_views = on;
select c2, 200 from aqumv_t1 where c1 = 4;
 c2 | ?column? 
----+----------
  5 |      200
  5 |      200
(2 rows)

select c2, 1, sqrt(100) from aqumv_t1 where c1 = 4;
 c2 | ?column? | sqrt 
----+----------+------
  5 |        1 |   10
  5 |        1 |   10
(2 rows)

-- Const are copied to output.
explain(verbose, costs off) select c2, 200 from aqumv_t1 where c1 = 4;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c2, 200
   ->  Seq Scan on public.aqumv_mvt1_nonvar_expr
         Output: c2, 200
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

explain(verbose, costs off) select c2, 1, sqrt(100) from aqumv_t1 where c1 = 4;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c2, 1, '10'::double precision
   ->  Seq Scan on public.aqumv_mvt1_nonvar_expr
         Output: c2, 1, '10'::double precision
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

abort;
begin;
CREATE OR REPLACE FUNCTION aqumv_func(i integer, j integer) RETURNS integer AS $$
    BEGIN
        RETURN i + j;
    END;
$$ LANGUAGE plpgsql IMMUTABLE;
create incremental materialized view aqumv_mvt1_func_has_var as
  select c2, aqumv_func(c1, c3) as mc_func_res
  from aqumv_t1 where c1 = 5;
analyze aqumv_mvt1_func_has_var;
set local enable_answer_query_using_materialized_views = off; 
select c2, aqumv_func(c1, c3) from aqumv_t1 where c1 = 5;
 c2 | aqumv_func 
----+------------
  6 |         12
  6 |         12
(2 rows)

set local enable_answer_query_using_materialized_views = on;
select c2, aqumv_func(c1, c3) from aqumv_t1 where c1 = 5;
 c2 | aqumv_func 
----+------------
  6 |         12
  6 |         12
(2 rows)

-- Functions has Vars are replaced.
explain(verbose, costs off) select c2, aqumv_func(c1, c3), aqumv_func(c1, c3) from aqumv_t1 where c1 = 5;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c2, mc_func_res, mc_func_res
   ->  Seq Scan on public.aqumv_mvt1_func_has_var
         Output: c2, mc_func_res, mc_func_res
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

abort;
begin;
create incremental materialized view aqumv_mvt1_2 as select c2 as mc2, c1 as mc1 from aqumv_t1 where c1 > 1 and c1 < 5;
analyze aqumv_mvt1_2;
set local enable_answer_query_using_materialized_views = on;
-- shoud be unable to use mv, projection doesn't exit in mv's tlist 
explain(verbose, costs off) select c3 from aqumv_t1 where c1 < 5 and c1 > 1;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c3
   ->  Seq Scan on public.aqumv_t1
         Output: c3
         Filter: ((aqumv_t1.c1 < 5) AND (aqumv_t1.c1 > 1))
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

-- no post quals.
explain(verbose, costs off) select c1, c2 from aqumv_t1 where c1 < 5 and c1 > 1;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, mc2
   ->  Seq Scan on public.aqumv_mvt1_2
         Output: mc1, mc2
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

-- post quals added to mv.
set local enable_answer_query_using_materialized_views = off;
select c1, c2 from aqumv_t1 where c1 < 5 and c1 > 1 and c2 = 4;
 c1 | c2 
----+----
  3 |  4
  3 |  4
(2 rows)

set local enable_answer_query_using_materialized_views = on;
select c1, c2 from aqumv_t1 where c1 < 5 and c1 > 1 and c2 = 4;
 c1 | c2 
----+----
  3 |  4
  3 |  4
(2 rows)

explain(verbose, costs off) select c1, c2 from aqumv_t1 where c1 < 5 and c1 > 1 and c2 = 4;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   Output: mc1, mc2
   ->  Seq Scan on public.aqumv_mvt1_2
         Output: mc1, mc2
         Filter: (aqumv_mvt1_2.mc2 = 4)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

-- should be unable to use mv, post quals has column doesn't exit in mv's tlist.
explain(verbose, costs off) select * from aqumv_t1 where c1 < 5 and c1 > 1 and c3 > 1; 
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c1, c2, c3
   ->  Seq Scan on public.aqumv_t1
         Output: c1, c2, c3
         Filter: ((aqumv_t1.c1 < 5) AND (aqumv_t1.c1 > 1) AND (aqumv_t1.c3 > 1))
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

abort;
begin;
create incremental materialized view aqumv_mvt1_3 as select c2 as mc2, c1 as mc1, c3+1 as mc3 from aqumv_t1 where c1 > 5 and c1 < 10;
analyze aqumv_mvt1_3;
set local enable_answer_query_using_materialized_views = on;
-- should be unable to use mv, column c3 doesn't exist in mv's tlist.
explain(verbose, costs off) select * from aqumv_t1 where c1 > 5 and c1 < 10; 
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: c1, c2, c3
   ->  Seq Scan on public.aqumv_t1
         Output: c1, c2, c3
         Filter: ((aqumv_t1.c1 > 5) AND (aqumv_t1.c1 < 10))
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

-- expr c3+1 is in mv's tlist
explain(verbose, costs off) select c1 as col1, c3+1 as col2 from aqumv_t1 where c1 > 5 and c1 < 10; 
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, mc3
   ->  Seq Scan on public.aqumv_mvt1_3
         Output: mc1, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

-- expr c1+1 could be derived from mv's tlist
explain(verbose, costs off) select c1+1 as col1, c2, c3+1 as col2 from aqumv_t1 where c1 > 5 and c1 < 10; 
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: ((mc1 + 1)), mc2, mc3
   ->  Seq Scan on public.aqumv_mvt1_3
         Output: (mc1 + 1), mc2, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

select c1 as col1, c3+1 as col2 from aqumv_t1 where c1 > 5 and c1 < 10; 
 col1 | col2 
------+------
    6 |    9
    9 |   12
    6 |    9
    9 |   12
    7 |   10
    8 |   11
    7 |   10
    8 |   11
(8 rows)

select c1+1 as col1, c2, c3+1 as col2 from aqumv_t1 where c1 > 5 and c1 < 10; 
 col1 | c2 | col2 
------+----+------
    7 |  7 |    9
   10 | 10 |   12
    7 |  7 |    9
   10 | 10 |   12
    8 |  8 |   10
    9 |  9 |   11
    8 |  8 |   10
    9 |  9 |   11
(8 rows)

set local enable_answer_query_using_materialized_views = off;
select c1 as col1, c3+1 as col2 from aqumv_t1 where c1 > 5 and c1 < 10; 
 col1 | col2 
------+------
    7 |   10
    8 |   11
    7 |   10
    8 |   11
    6 |    9
    9 |   12
    6 |    9
    9 |   12
(8 rows)

select c1+1 as col1, c2, c3+1 as col2 from aqumv_t1 where c1 > 5 and c1 < 10; 
 col1 | c2 | col2 
------+----+------
    8 |  8 |   10
    9 |  9 |   11
    8 |  8 |   10
    9 |  9 |   11
    7 |  7 |    9
   10 | 10 |   12
    7 |  7 |    9
   10 | 10 |   12
(8 rows)

abort;
begin;
create incremental materialized view aqumv_mvt1_4 as
  select c1 as mc1, c2 as mc2, abs(c2) as mc3, abs(abs(c2) - c1 - 1) as mc4
  from aqumv_t1 where c1 > 10 and c1 < 15;
analyze aqumv_mvt1_4;
set local enable_answer_query_using_materialized_views = on;
-- complex exprs
explain(verbose, costs off) select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1 from aqumv_t1 where c1 > 10 and c1 < 15;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, ((sqrt(((mc4 + mc3))::double precision) + '1'::double precision)), ((mc3 + 1))
   ->  Seq Scan on public.aqumv_mvt1_4
         Output: mc1, (sqrt(((mc4 + mc3))::double precision) + '1'::double precision), (mc3 + 1)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(6 rows)

select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1 from aqumv_t1 where c1 > 10 and c1 < 15;
 c1 |     ?column?      | ?column? 
----+-------------------+----------
 12 |  4.60555127546399 |       14
 12 |  4.60555127546399 |       14
 11 | 4.464101615137754 |       13
 13 | 4.741657386773941 |       15
 14 | 4.872983346207417 |       16
 11 | 4.464101615137754 |       13
 13 | 4.741657386773941 |       15
 14 | 4.872983346207417 |       16
(8 rows)

set local enable_answer_query_using_materialized_views = off;
select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1 from aqumv_t1 where c1 > 10 and c1 < 15;
 c1 |     ?column?      | ?column? 
----+-------------------+----------
 11 | 4.464101615137754 |       13
 13 | 4.741657386773941 |       15
 14 | 4.872983346207417 |       16
 11 | 4.464101615137754 |       13
 13 | 4.741657386773941 |       15
 14 | 4.872983346207417 |       16
 12 |  4.60555127546399 |       14
 12 |  4.60555127546399 |       14
(8 rows)

abort;
-- post quals
begin;
create incremental materialized view aqumv_mvt1_post_quals as
  select c1 as mc1, c2 as mc2, abs(c2) as mc3, abs(abs(c2) - c1 - 1) as mc4
  from aqumv_t1 where c1 > 20 and c1 < 30;
analyze aqumv_mvt1_post_quals;
set local enable_answer_query_using_materialized_views = on;
explain(verbose, costs off)
  select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(c2) + 1) > 1;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, ((sqrt(((mc4 + mc3))::double precision) + '1'::double precision)), ((mc3 + 1))
   ->  Seq Scan on public.aqumv_mvt1_post_quals
         Output: mc1, (sqrt(((mc4 + mc3))::double precision) + '1'::double precision), (mc3 + 1)
         Filter: (sqrt(((aqumv_mvt1_post_quals.mc3 + 1))::double precision) > '1'::double precision)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

explain(verbose, costs off)
  select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(c2) + 1) > abs(c1) + 2;
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, ((sqrt(((mc4 + mc3))::double precision) + '1'::double precision)), ((mc3 + 1))
   ->  Seq Scan on public.aqumv_mvt1_post_quals
         Output: mc1, (sqrt(((mc4 + mc3))::double precision) + '1'::double precision), (mc3 + 1)
         Filter: (sqrt(((aqumv_mvt1_post_quals.mc3 + 1))::double precision) > ((abs(aqumv_mvt1_post_quals.mc1) + 2))::double precision)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

explain(verbose, costs off)
select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(abs(c2) - c1 - 1) + 10) > 2; 
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: mc1, ((sqrt(((mc4 + mc3))::double precision) + '1'::double precision)), ((mc3 + 1))
   ->  Seq Scan on public.aqumv_mvt1_post_quals
         Output: mc1, (sqrt(((mc4 + mc3))::double precision) + '1'::double precision), (mc3 + 1)
         Filter: (sqrt(((aqumv_mvt1_post_quals.mc4 + 10))::double precision) > '2'::double precision)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(c2) + 1) > 1;
 c1 |      ?column?      | ?column? 
----+--------------------+----------
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
(18 rows)

select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(c2) + 1) > abs(c1) + 2;
 c1 | ?column? | ?column? 
----+----------+----------
(0 rows)

select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(abs(c2) - c1 - 1) + 10) > 2; 
 c1 |      ?column?      | ?column? 
----+--------------------+----------
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
(18 rows)

set local enable_answer_query_using_materialized_views = off;
select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(c2) + 1) > 1;
 c1 |      ?column?      | ?column? 
----+--------------------+----------
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
(18 rows)

select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(c2) + 1) > abs(c1) + 2;
 c1 | ?column? | ?column? 
----+----------+----------
(0 rows)

select c1, sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) + 1, abs(c2) + 1
  from aqumv_t1 where c1 > 20 and c1 < 30 and sqrt(abs(abs(c2) - c1 - 1) + 10) > 2; 
 c1 |      ?column?      | ?column? 
----+--------------------+----------
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
 21 |   5.69041575982343 |       23
 25 | 6.0990195135927845 |       27
 28 |  6.385164807134504 |       30
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 22 |  5.795831523312719 |       24
 24 |                  6 |       26
 27 |  6.291502622129181 |       29
 29 |  6.477225575051661 |       31
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
 23 |  5.898979485566356 |       25
 26 |  6.196152422706632 |       28
(18 rows)

abort;
-- choose the best one if there are multiple chooses based on cost.
begin;
set local enable_answer_query_using_materialized_views = on;
create incremental materialized view aqumv_mvt1_candidate_0 as
  select c1 as mc1, c2 as mc2, abs(c2) as mc3
  from aqumv_t1 where c1 > 30;
analyze aqumv_mvt1_candidate_0;
-- choose aqumv_mvt1_candidate_0
explain(verbose, costs off)
select sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) from aqumv_t1 where c1 > 30 and c1 < 40 and sqrt(abs(c2)) > 5.8;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (sqrt(((abs(((mc3 - mc1) - 1)) + mc3))::double precision))
   ->  Seq Scan on public.aqumv_mvt1_candidate_0
         Output: sqrt(((abs(((mc3 - mc1) - 1)) + mc3))::double precision)
         Filter: ((aqumv_mvt1_candidate_0.mc1 < 40) AND (sqrt((aqumv_mvt1_candidate_0.mc3)::double precision) > '5.8'::double precision))
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

create incremental materialized view aqumv_mvt1_candidate_1 as
  select c1 as mc1, c2 as mc2, abs(c2) as mc3, abs(abs(c2) - c1 - 1) as mc4
  from aqumv_t1 where c1 > 30 and c1 < 40;
analyze aqumv_mvt1_candidate_1;
-- choose aqumv_mvt1_candidate_1 as it has lower cost(less rows).
explain(verbose, costs off)
select sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) from aqumv_t1 where c1 > 30 and c1 < 40 and sqrt(abs(c2)) > 5.8;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (sqrt(((mc4 + mc3))::double precision))
   ->  Seq Scan on public.aqumv_mvt1_candidate_1
         Output: sqrt(((mc4 + mc3))::double precision)
         Filter: (sqrt((aqumv_mvt1_candidate_1.mc3)::double precision) > '5.8'::double precision)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

create incremental materialized view aqumv_mvt1_candidate_2 as
  select c1 as mc1, c2 as mc2, abs(c2) as mc3, abs(abs(c2) - c1 - 1) as mc4
  from aqumv_t1 where c1 > 30 and c1 < 500;
analyze aqumv_mvt1_candidate_2;
-- still choose aqumv_mvt1_candidate_1 as it has lowest cost(less rows).
explain(verbose, costs off)
select sqrt(abs(abs(c2) - c1 - 1) + abs(c2)) from aqumv_t1 where c1 > 30 and c1 < 40 and sqrt(abs(c2)) > 5.8;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   Output: (sqrt(((mc4 + mc3))::double precision))
   ->  Seq Scan on public.aqumv_mvt1_candidate_1
         Output: sqrt(((mc4 + mc3))::double precision)
         Filter: (sqrt((aqumv_mvt1_candidate_1.mc3)::double precision) > '5.8'::double precision)
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(7 rows)

abort;
--
-- Support origin query with aggregations.
-- Compute Aggregations from mv.
--
begin;
create table aqumv_t2(c1 int, c2 int, c3 int) distributed by (c1);
insert into aqumv_t2 select i, i+1, i+2 from generate_series(1, 100) i;
insert into aqumv_t2 values (91, NULL, 95);
analyze aqumv_t2;
create incremental materialized view aqumv_mvt2_0 as
  select c1 as mc1, c2 as mc2, c3 as mc3
  from aqumv_t2 where c1 > 90;
analyze aqumv_mvt2_0;
-- test aggregation functions supported in IVM. 
set local enable_answer_query_using_materialized_views = off;
explain(costs off, verbose)
select count(c1), sum(c2), avg(c3) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(c1), sum(c2), avg(c3)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(c1)), (PARTIAL sum(c2)), (PARTIAL avg(c3))
         ->  Partial Aggregate
               Output: PARTIAL count(c1), PARTIAL sum(c2), PARTIAL avg(c3)
               ->  Seq Scan on public.aqumv_t2
                     Output: c1, c2, c3
                     Filter: (aqumv_t2.c1 > 90)
 Settings: enable_answer_query_using_materialized_views = 'off', optimizer = 'off'
 Optimizer: Postgres query optimizer
(11 rows)

select count(c1), sum(c2), avg(c3) from aqumv_t2 where c1 > 90;
 count | sum |         avg         
-------+-----+---------------------
    11 | 965 | 97.2727272727272727
(1 row)

set local enable_answer_query_using_materialized_views = on;
explain(costs off, verbose)
select count(c1), sum(c2), avg(c3) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(mc1), sum(mc2), avg(mc3)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(mc1)), (PARTIAL sum(mc2)), (PARTIAL avg(mc3))
         ->  Partial Aggregate
               Output: PARTIAL count(mc1), PARTIAL sum(mc2), PARTIAL avg(mc3)
               ->  Seq Scan on public.aqumv_mvt2_0
                     Output: mc1, mc2, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(10 rows)

select count(c1), sum(c2), avg(c3) from aqumv_t2 where c1 > 90;
 count | sum |         avg         
-------+-----+---------------------
    11 | 965 | 97.2727272727272727
(1 row)

-- test complex expressions have AGG.
set local enable_answer_query_using_materialized_views = off;
explain(costs off, verbose)
select count(c1) + 1 from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count(c1) + 1)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(c1))
         ->  Partial Aggregate
               Output: PARTIAL count(c1)
               ->  Seq Scan on public.aqumv_t2
                     Output: c1, c2, c3
                     Filter: (aqumv_t2.c1 > 90)
 Settings: enable_answer_query_using_materialized_views = 'off', optimizer = 'off'
 Optimizer: Postgres query optimizer
(11 rows)

select count(c1) + 1 from aqumv_t2 where c1 > 90;
 ?column? 
----------
       12
(1 row)

set local enable_answer_query_using_materialized_views = on;
explain(costs off, verbose)
select count(c1) + 1 from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: (count(mc1) + 1)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(mc1))
         ->  Partial Aggregate
               Output: PARTIAL count(mc1)
               ->  Seq Scan on public.aqumv_mvt2_0
                     Output: mc1, mc2, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(10 rows)

select count(c1) + 1 from aqumv_t2 where c1 > 90;
 ?column? 
----------
       12
(1 row)

-- test AGG FILTER.
set local enable_answer_query_using_materialized_views = off;
explain(costs off, verbose)
select sum(c2), sum(c2) filter (where c2 > 95) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: sum(c2), sum(c2) FILTER (WHERE (c2 > 95))
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL sum(c2)), (PARTIAL sum(c2) FILTER (WHERE (c2 > 95)))
         ->  Partial Aggregate
               Output: PARTIAL sum(c2), PARTIAL sum(c2) FILTER (WHERE (c2 > 95))
               ->  Seq Scan on public.aqumv_t2
                     Output: c1, c2, c3
                     Filter: (aqumv_t2.c1 > 90)
 Settings: enable_answer_query_using_materialized_views = 'off', optimizer = 'off'
 Optimizer: Postgres query optimizer
(11 rows)

select sum(c2), sum(c2) filter (where c2 > 95) from aqumv_t2 where c1 > 90;
 sum | sum 
-----+-----
 965 | 591
(1 row)

set local enable_answer_query_using_materialized_views = on;
explain(costs off, verbose)
select sum(c2), sum(c2) filter (where c2 > 95) from aqumv_t2 where c1 > 90;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Finalize Aggregate
   Output: sum(mc2), sum(mc2) FILTER (WHERE (mc2 > 95))
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL sum(mc2)), (PARTIAL sum(mc2) FILTER (WHERE (mc2 > 95)))
         ->  Partial Aggregate
               Output: PARTIAL sum(mc2), PARTIAL sum(mc2) FILTER (WHERE (mc2 > 95))
               ->  Seq Scan on public.aqumv_mvt2_0
                     Output: mc1, mc2, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(10 rows)

select sum(c2), sum(c2) filter (where c2 > 95) from aqumv_t2 where c1 > 90;
 sum | sum 
-----+-----
 965 | 591
(1 row)

-- test AGG functions which are not supported in IVM now, but could work in AQUMV. 
set local enable_answer_query_using_materialized_views = off;
explain(costs off, verbose)
select max(c1), min(c3), stddev(c2) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: max(c1), min(c3), stddev(c2)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL max(c1)), (PARTIAL min(c3)), (PARTIAL stddev(c2))
         ->  Partial Aggregate
               Output: PARTIAL max(c1), PARTIAL min(c3), PARTIAL stddev(c2)
               ->  Seq Scan on public.aqumv_t2
                     Output: c1, c2, c3
                     Filter: (aqumv_t2.c1 > 90)
 Settings: enable_answer_query_using_materialized_views = 'off', optimizer = 'off'
 Optimizer: Postgres query optimizer
(11 rows)

select max(c1), min(c3), stddev(c2) from aqumv_t2 where c1 > 90;
 max | min |       stddev       
-----+-----+--------------------
 100 |  93 | 3.0276503540974917
(1 row)

set local enable_answer_query_using_materialized_views = on;
explain(costs off, verbose)
select max(c1), min(c3), stddev(c2) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: max(mc1), min(mc3), stddev(mc2)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL max(mc1)), (PARTIAL min(mc3)), (PARTIAL stddev(mc2))
         ->  Partial Aggregate
               Output: PARTIAL max(mc1), PARTIAL min(mc3), PARTIAL stddev(mc2)
               ->  Seq Scan on public.aqumv_mvt2_0
                     Output: mc1, mc2, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(10 rows)

select max(c1), min(c3), stddev(c2) from aqumv_t2 where c1 > 90;
 max | min |       stddev       
-----+-----+--------------------
 100 |  93 | 3.0276503540974917
(1 row)

-- test count(*)
set local enable_answer_query_using_materialized_views = off;
explain(costs off, verbose)
select count(c2), count(*) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(c2), count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(c2)), (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(c2), PARTIAL count(*)
               ->  Seq Scan on public.aqumv_t2
                     Output: c1, c2, c3
                     Filter: (aqumv_t2.c1 > 90)
 Settings: enable_answer_query_using_materialized_views = 'off', optimizer = 'off'
 Optimizer: Postgres query optimizer
(11 rows)

select count(c2), count(*) from aqumv_t2 where c1 > 90;
 count | count 
-------+-------
    10 |    11
(1 row)

set local enable_answer_query_using_materialized_views = on;
explain(costs off, verbose)
select count(c2), count(*) from aqumv_t2 where c1 > 90;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Finalize Aggregate
   Output: count(mc2), count(*)
   ->  Gather Motion 3:1  (slice1; segments: 3)
         Output: (PARTIAL count(mc2)), (PARTIAL count(*))
         ->  Partial Aggregate
               Output: PARTIAL count(mc2), PARTIAL count(*)
               ->  Seq Scan on public.aqumv_mvt2_0
                     Output: mc1, mc2, mc3
 Settings: enable_answer_query_using_materialized_views = 'on', optimizer = 'off'
 Optimizer: Postgres query optimizer
(10 rows)

select count(c2), count(*) from aqumv_t2 where c1 > 90;
 count | count 
-------+-------
    10 |    11
(1 row)

abort;
reset optimizer;
reset enable_answer_query_using_materialized_views;
drop table aqumv_t1 cascade;
